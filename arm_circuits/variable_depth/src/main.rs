// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use risc0_zkvm::sha::Digest;
use risc0_zkvm::{default_prover, ExecutorEnv, ProverOpts, VerifierContext};
use std::time::Instant;
use variable_depth_methods::{VARIABLE_DEPTH_GUEST_ELF, VARIABLE_DEPTH_GUEST_ID};

fn main() {
    let env = ExecutorEnv::builder()
        // .write(&(path, leaf))
        // .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();
    // let prover_opts = ProverOpts::fast();
    let prover_opts = ProverOpts::composite();
    // let prover_opts = ProverOpts::succinct();
    // let prover_opts = ProverOpts::groth16();

    let prove_start_timer = Instant::now();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove_with_ctx(
            env,
            &VerifierContext::default(),
            VARIABLE_DEPTH_GUEST_ELF,
            &prover_opts,
        )
        .unwrap();

    let prove_duration = prove_start_timer.elapsed();
    println!("Variable depth prove duration time: {:?}", prove_duration);

    // extract the receipt.
    let receipt = prove_info.receipt;
    println!("proof size: {:?}", receipt.seal_size());

    // let output: (Digest, Vec<(Digest, bool)>, u32) = receipt.journal.decode().unwrap();
    // println!("output: {:?}", output);

    let verify_start_timer = Instant::now();

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(VARIABLE_DEPTH_GUEST_ID).unwrap();
    println!("id: {:?}", Digest::from(VARIABLE_DEPTH_GUEST_ID));

    let verify_duration = verify_start_timer.elapsed();
    println!("Variable depth verify duration time: {:?}", verify_duration);
}
