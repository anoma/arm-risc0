use crate::{
    compliance::{
        ComplianceInstance, ComplianceSigmabusWitness, ComplianceVarWitness, ComplianceWitness,
        SigmabusCircuitWitness,
    },
    constants::{
        COMPLIANCE_PK, COMPLIANCE_SIGMABUS_PK, COMPLIANCE_SIGMABUS_VK, COMPLIANCE_VAR_PK,
        COMPLIANCE_VAR_VK, COMPLIANCE_VK,
    },
    error::ArmError,
    proving_system::{journal_to_instance, prove, verify as verify_proof},
    sigma::{SigmaProof, SigmaProtocol},
};
use k256::ProjectivePoint;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ComplianceUnit {
    // vk is a constant in the compliance unit, so we don't place it here.
    pub proof: Option<Vec<u8>>,
    pub instance: Vec<u8>,
}

impl ComplianceUnit {
    // Proving key and verifying key are constants, so we don't need to pass
    // them as parameters. Instance is generated by proving.
    pub fn create(witness: &ComplianceWitness) -> Result<Self, ArmError> {
        let (proof, instance) = prove(COMPLIANCE_PK, witness)?;
        Ok(ComplianceUnit {
            proof: Some(proof),
            instance,
        })
    }

    pub fn verify(&self) -> Result<(), ArmError> {
        if let Some(proof) = &self.proof {
            verify_proof(&COMPLIANCE_VK, &self.instance, proof)
        } else {
            Err(ArmError::ProofVerificationFailed(
                "Missing compliance proof".into(),
            ))
        }
    }

    pub fn delta(&self) -> Result<ProjectivePoint, ArmError> {
        self.get_instance()?.delta_projective()
    }

    pub fn get_instance(&self) -> Result<ComplianceInstance, ArmError> {
        journal_to_instance(&self.instance)
    }
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ComplianceVarUnit {
    // vk is a constant in the compliance unit, so we don't place it here.
    pub proof: Option<Vec<u8>>,
    pub instance: Vec<u8>,
}

impl ComplianceVarUnit {
    // Proving key and verifying key are constants, so we don't need to pass
    // them as parameters. Instance is generated by proving.
    pub fn create(witness: &ComplianceVarWitness) -> Result<Self, ArmError> {
        let (proof, instance) = prove(COMPLIANCE_VAR_PK, witness)?;
        Ok(ComplianceVarUnit {
            proof: Some(proof),
            instance,
        })
    }

    pub fn verify(&self) -> Result<(), ArmError> {
        if let Some(proof) = &self.proof {
            verify_proof(&COMPLIANCE_VAR_VK, &self.instance, proof)
        } else {
            Err(ArmError::ProofVerificationFailed(
                "Missing compliance proof".into(),
            ))
        }
    }
}

#[derive(Clone, Debug)]
pub struct ComplianceSigmabusUnit {
    /// RISC0 proof
    pub circuit_proof: Option<Vec<u8>>,
    /// RISC0 instance
    pub circuit_instance: Vec<u8>,
    /// Sigma proof
    pub sigma_proof: SigmaProof,
    /// Sigma instance (Delta commitments)
    pub sigma_instance: Vec<ProjectivePoint>,
}

impl ComplianceSigmabusUnit {
    // Proving key and verifying key are constants, so we don't need to pass
    // them as parameters. Instance is generated by proving.
    pub fn create(witness: &ComplianceSigmabusWitness) -> Result<Self, ArmError> {
        // Prove off-circuit
        let sigma_instance = witness.compute_deltas();
        let sigma_proof = SigmaProtocol::prove(&sigma_instance, &witness.sigma_witness)?;
        // Prove on-circuit
        let circuit_witness =
            SigmabusCircuitWitness::from_sigmabus_witness_proof(witness, &sigma_proof);
        let (circuit_proof, circuit_instance) = prove(COMPLIANCE_SIGMABUS_PK, &circuit_witness)?;

        Ok(ComplianceSigmabusUnit {
            circuit_proof: Some(circuit_proof),
            circuit_instance,
            sigma_proof,
            sigma_instance,
        })
    }

    pub fn verify(&self) -> Result<(), ArmError> {
        if SigmaProtocol::verify(&self.sigma_instance, &self.sigma_proof).is_err() {
            return Err(ArmError::ProofVerificationFailed(
                "Invalid sigma proof".into(),
            ));
        }
        if let Some(proof) = &self.circuit_proof {
            if verify_proof(&COMPLIANCE_SIGMABUS_VK, &self.circuit_instance, proof).is_err() {
                return Err(ArmError::ProofVerificationFailed(
                    "Invalid compliance circuit proof".into(),
                ));
            }
            Ok(())
        } else {
            Err(ArmError::ProofVerificationFailed(
                "Missing compliance circuit proof".into(),
            ))
        }
    }
}
